
# SQL Portfolio Project: Business analysis

This repository contains SQL queries used for various data analysis tasks. The queries focus on sales performance, customer segmentation, product categorization, and trend analysis. 

---

## Dataset Source
The dataset utilized in this project is stored as CSV files within this Git repository.



---

## Database Setup
A custom script was created to generate the necessary tables in the database, followed by populating them with data from the CSV files using bulk insert functionality

## Queries

### 1. **Magnitude analysis**
```sql
-- What is the total revenue generated for each category?
SELECT
    p.category,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.category
ORDER BY total_revenue DESC;
```
**Description**: 
Calculates the total revenue for each product category by joining sales and product data.

```sql
-- What is the total revenue generated by each customer?
SELECT
    c.customer_key,
    c.first_name,
    c.last_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_revenue DESC;
```
**Description**: 
Second Query: Calculates the total revenue generated by each customer by joining sales and customer data.

```sql
-- What is the distribution of sold items across countries?
SELECT
    c.country,
    SUM(f.quantity) AS total_sold_items
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY c.country
ORDER BY total_sold_items DESC;
```
**Description**: 
Analyzes the distribution of sold items across different countries by joining sales and customer data.

---

### 2. **Ranking analysis**
```sql
-- Which 5 products Generating the Highest Revenue?
-- Simple Ranking
SELECT TOP 5
    p.product_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue DESC;
```
**Description**: 
Retrieves the top 5 products generating the highest revenue by summing sales and ordering them in descending order.

```sql
-- Complex but Flexibly Ranking Using Window Functions
SELECT *
FROM (
    SELECT
        p.product_name,
        SUM(f.sales_amount) AS total_revenue,
        RANK() OVER (ORDER BY SUM(f.sales_amount) DESC) AS rank_products
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON p.product_key = f.product_key
    GROUP BY p.product_name
) AS ranked_products
WHERE rank_products <= 5;
```
**Description**: 
Uses the RANK() window function to flexibly rank products by total revenue and returns the top 5 performing products.
```sql
-- What are the 5 worst-performing products in terms of sales?
SELECT TOP 5
    p.product_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue;
```
**Description**: 
Identifies the 5 products with the lowest sales revenue by summing sales and ordering them in ascending order.
```sql
-- Find the top 10 customers who have generated the highest revenue
SELECT TOP 10
    c.customer_key,
    c.first_name,
    c.last_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_revenue DESC;
```
**Description**: 
Retrieves the top 10 customers who generated the highest total revenue.

---

### 3. **Change Over time analysis**
```sql
SELECT 
    YEAR(order_date) AS order_year, 
    MONTH(order_date) AS order_month, 
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS total_customers
FROM [DGED_S481821].[DBO].[GOLD.FACT_SALES]
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date), MONTH(order_date)
ORDER BY YEAR(order_date), MONTH(order_date);
```
**Description**: 
Uses the YEAR() and MONTH() functions to extract the year and month separately for grouping and calculating total sales and customers. It groups by the individual year and month components.

```sql
-- Alternative method using DATE truncation
SELECT 
    DATETRUNC(MONTH, order_date) AS order_date, 
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS total_customers
FROM [DGED_S481821].[DBO].[GOLD.FACT_SALES]
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(MONTH, order_date)
ORDER BY DATETRUNC(MONTH, order_date);
```
**Description**: 
Second Query: Uses the DATETRUNC(MONTH, order_date) function to truncate the order_date to the first day of the month, grouping by the truncated date. This method avoids separating the year and month explicitly.

```sql
-- FORMAT function produces strings; be cautious with sorting
SELECT 
    FORMAT(order_date, 'yyyy-MMM') AS order_date, 
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS total_customers
FROM [DGED_S481821].[DBO].[GOLD.FACT_SALES]
WHERE order_date IS NOT NULL
GROUP BY FORMAT(order_date, 'yyyy-MMM')
ORDER BY FORMAT(order_date, 'yyyy-MMM');
```
**Description**: 
Uses the FORMAT() function to convert the order_date into a string formatted as 'yyyy-MMM' (e.g., "2025-Mar") for grouping and sorting. While this provides a readable format, sorting may not behave as expected because the result is a string rather than a date.

---

### 4. **Running total**
```sql
SELECT
    order_year,
    order_month,
    total_sales,
    SUM(total_sales) OVER (PARTITION BY order_year ORDER BY order_year, order_month) AS running_total_sales
FROM 
(
    SELECT
        DATEPART(YEAR, order_date) AS order_year, 
        DATEPART(MONTH, order_date) AS order_month, 
        SUM(sales_amount) AS total_sales 
    FROM [DGED_S481821].[DBO].[GOLD.FACT_SALES]
    WHERE order_date IS NOT NULL
    GROUP BY DATEPART(YEAR, order_date), DATEPART(MONTH, order_date)
) AS t
ORDER BY order_year, order_month;
```
**Description**:
Calculates the running total of sales for each month of a given year. The inner query groups sales by year and month, summing up the sales for each period. The outer query uses the SUM() window function with OVER (PARTITION BY order_year ORDER BY order_year, order_month) to calculate the cumulative total, which accumulates sales month by month within each year. This helps to track the progressive sales performance over time.

---

### 5. **Performance analysis of product sales**
```sql
-- Performance analysis: Compare product sales to average and previous year
WITH yearly_product_sales AS (
    SELECT 
        DATEPART(YEAR, order_date) AS current_year, 
        p.product_name, 
        SUM(f.sales_amount) AS total_sales
    FROM [DGED_S481821].[DBO].[GOLD.FACT_SALES] f
    LEFT JOIN [DGED_S481821].[DBO].[DGED_S481821].[DBO].[GOLD.DIM_PRODUCTS] p
        ON f.product_key = p.product_key
    WHERE order_date IS NOT NULL
    GROUP BY DATEPART(YEAR, order_date), p.product_name
)
SELECT
    current_year,
    product_name,
    total_sales,
    AVG(total_sales) OVER(PARTITION BY product_name) AS avg_product_sales, 
    total_sales - AVG(total_sales) OVER(PARTITION BY product_name) AS diff_from_avg, 
    CASE 
        WHEN total_sales - AVG(total_sales) OVER(PARTITION BY product_name) > 0 THEN 'ABOVE AVG'
        WHEN total_sales - AVG(total_sales) OVER(PARTITION BY product_name) < 0 THEN 'BELOW AVG'
        ELSE 'NO CHANGE'
    END AS avg_change,
    LAG(total_sales) OVER(PARTITION BY product_name ORDER BY current_year) AS prev_sales,
    total_sales - LAG(total_sales) OVER(PARTITION BY product_name ORDER BY current_year) AS diff_from_prev,
    CASE 
        WHEN total_sales - LAG(total_sales) OVER(PARTITION BY product_name ORDER BY current_year) > 0 THEN 'INCREASE'
        WHEN total_sales - LAG(total_sales) OVER(PARTITION BY product_name ORDER BY current_year) < 0 THEN 'DECREASE'
        ELSE 'NO CHANGE'
    END AS prev_change
FROM yearly_product_sales
ORDER BY product_name, current_year;
```

---

### 6. **Part-to-whole analysis**
```sql
WITH category_sales AS (
    SELECT 
        category,
        SUM(sales_amount) AS total_sales
    FROM [DGED_S481821].[DBO].[GOLD.FACT_SALES] f
    LEFT JOIN [DGED_S481821].[DBO].[DGED_S481821].[DBO].[GOLD.DIM_PRODUCTS] p
        ON f.product_key = p.product_key
    GROUP BY category
)
SELECT 
    category,
    total_sales,
    CONCAT(ROUND((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER()) * 100,2), '%') AS percentage_of_total
FROM category_sales
ORDER BY total_sales DESC;
```

---

### 7. **Data segmentation: Classify products by cost range**
```sql
WITH products_cte AS (
    SELECT
        product_key,
        product_name,
        cost,
        CASE 
            WHEN cost < 500 THEN 'BELOW 500'
            WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
            ELSE '1000+'
        END AS cost_range
    FROM [DGED_S481821].[DBO].[GOLD.DIM_PRODUCTS]
)
SELECT 
    cost_range,
    COUNT(product_key) AS total_products
FROM products_cte
GROUP BY cost_range;
```

---

### 8. **Classify customers into VIP, Regular, and New based on spending and duration**
```sql
WITH client_cte AS (
    SELECT
        c.customer_key,
        SUM(f.sales_amount) AS total_spending,
        MIN(order_date) AS first_order,
        MAX(order_date) AS last_order,
        CASE 
            WHEN DATEDIFF(YEAR, MIN(order_date), MAX(order_date)) < 1 THEN 'LESS THAN 1 YEAR'
            ELSE '1 YEAR+'
        END AS years_being_client,
        CASE 
            WHEN SUM(f.sales_amount) < 5000 THEN 'LOW SPENDER'
            ELSE 'HIGH SPENDER'
        END AS type_of_spenders
    FROM [GOLD.DIM_CUSTOMERS] c 
    LEFT JOIN [GOLD.FACT_SALES] f 
        ON f.customer_key = c.customer_key
    GROUP BY c.customer_key
)
SELECT
    type_of_customer AS customer_category, 
    COUNT(customer_key) AS count_of_customer_types
FROM (
    SELECT 
        customer_key,
        CASE 
            WHEN type_of_spenders = 'HIGH SPENDER' AND years_being_client = '1 YEAR+' THEN 'VIP'
            WHEN type_of_spenders = 'LOW SPENDER' AND years_being_client = '1 YEAR+' THEN 'REGULAR'
            ELSE 'NEW'
        END AS type_of_customer
    FROM client_cte
) t
GROUP BY type_of_customer;
```

---

### 9. **Produce a customer raport**
```sql
-- 1) Base Query: Retrieves core columns from tables
WITH base_query AS (
    SELECT 
        f.order_number, 
        f.product_key,  
        f.order_date, 
        f.sales_amount,  
        f.quantity,  
        c.customer_key, 
        c.customer_number,  
        CONCAT(c.last_name, ' ', c.first_name) AS customer_name,  -- Full name of the customer
        DATEDIFF(YEAR, c.birthdate, GETDATE()) AS age  -- Calculates customer age based on birthdate
    FROM [gold.fact_sales] f
    LEFT JOIN [gold.dim_customers] c
        ON c.customer_key = f.customer_key 
    WHERE order_date IS NOT NULL  -- Exclude records with null order dates
),

-- 2) Customer Aggregations: Summarizes key metrics at the customer level
CUSTOMER_AGGREGATION AS (
    SELECT 
        customer_key,
        customer_number,
        customer_name,
        age,
        COUNT(DISTINCT order_number) AS total_orders,  -- Total number of unique orders placed by the customer
        SUM(sales_amount) AS total_sales,  -- Total revenue generated from the customer
        SUM(quantity) AS total_quantity_of_bought_items,  -- Total number of items purchased
        COUNT(DISTINCT product_key) AS total_diff_products,  -- Number of unique products purchased
        MAX(order_date) AS last_order,  -- Date of the most recent order
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan  -- Number of months between first and last order
    FROM base_query
    GROUP BY customer_key, customer_number, customer_name, age
)
SELECT
    customer_key,
    customer_number,
    customer_name,
    age,
    -- Categorizing customers based on age
    CASE 
        WHEN age < 20 THEN 'Under 20'
        WHEN age BETWEEN 20 AND 29 THEN '20-29'
        WHEN age BETWEEN 30 AND 39 THEN '30-39'
        WHEN age BETWEEN 40 AND 49 THEN '40-49'
        ELSE '50+'
    END AS type_of_customer,
    -- Categorizing customers based on their purchasing history
    CASE 
        WHEN lifespan >= 1 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 1 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_category,
    DATEDIFF(MONTH, last_order, GETDATE()) AS recency,  -- Number of months since the last order
    -- Calculate average order value (total sales divided by total orders)
    CASE 
        WHEN total_orders = 0 THEN 0
        ELSE (total_sales / total_orders) 
    END AS avg_order_value,
    total_orders,  
    total_sales,  
    total_quantity_of_bought_items, 
    total_diff_products,  
    -- Compute average monthly spend
    CASE 
        WHEN lifespan = 0 THEN total_sales
        ELSE total_sales / lifespan
    END AS avg_monthly_spend,
    lifespan  -- Customer's purchasing activity duration in months
FROM customer_aggregation;

```
